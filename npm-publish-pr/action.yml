name: npm-pr-version

description:
  Publishes package with PR-specific version (0.0.0-PR-123--abc1234) using detected package manager (npm/yarn/pnpm) or
  OIDC trusted publishing, and automatically comments on PR

inputs:
  npm-token:
    required: false
    description:
      Registry authentication token with publish permissions. If not provided, OIDC trusted publishing will be used.
  tarball:
    required: false
    description:
      Path to pre-built tarball to publish (e.g., '*.tgz'). When provided, publishes the tarball with --ignore-scripts
      for security. Recommended for pull_request_target workflows to prevent execution of malicious lifecycle scripts.
  comment:
    required: false
    default: 'true'
    description: Whether to comment on the PR with the published version (true/false)
  comment-tag:
    required: false
    default: npm-publish-pr
    description: Tag to use for PR comments (for comment identification and updates)

outputs:
  version:
    description: Generated PR-specific version number (0.0.0-PR-{number}--{short-sha})
    value: '${{ steps.publish.outputs.version }}'
  package-name:
    description: Package name from package.json
    value: '${{ steps.publish.outputs.package-name }}'
  error-message:
    description: Error message if publish fails
    value: '${{ steps.publish.outputs.error-message }}'

runs:
  using: composite

  steps:
    - uses: codfish/actions/comment@v3
      if: inputs.comment == 'true'
      with:
        message: ‚è≥ Publishing PR version...
        upsert: true
        tag: ${{ inputs.comment-tag }}

    - name: Validate and publish to registry
      id: publish
      shell: bash
      run: |
        set +e # Don't exit on error so we can handle failures

        # Initialize outputs for error handling
        error_message=""
        package_name=""
        version=""
        package_manager="npm"
        tarball_mode=false

        # Detect if tarball mode is being used
        if [ -n "$INPUT_TARBALL" ]; then
          tarball_mode=true
          echo "üîí SECURE MODE: Using pre-built tarball (lifecycle scripts will NOT execute)"
        fi

        # Function to extract relevant error message from npm output
        extract_error() {
          local output="$1"

          # Extract npm error lines (lines starting with "npm error")
          local error_lines=$(echo "$output" | grep "^npm error" | head -5)

          # If we found error lines, use those
          if [ -n "$error_lines" ]; then
            echo "$error_lines" | tr '\n' ' ' | tr -s ' '
          else
            # Otherwise, take the last few lines (likely contains the error)
            echo "$output" | tail -10 | tr '\n' ' ' | tr -s ' ' | cut -c1-500
          fi
        }

        # Standardized publish error handler
        handle_publish_error() {
          local manager_name="$1"
          local publish_output="$2"
          local extracted_error=""

          extracted_error=$(extract_error "$publish_output")
          error_message="‚ùå Failed to publish with ${manager_name}: ${extracted_error}"
          echo "Full output: $publish_output"
          echo "Error message: $error_message"
          echo "error-message=$error_message" >> $GITHUB_OUTPUT
          exit 1
        }

        # In tarball mode, extract package info from tarball
        # In normal mode, validate package.json
        if [ "$tarball_mode" = true ]; then
          # Validate tarball exists
          if [ ! -f "$INPUT_TARBALL" ]; then
            error_message="‚ùå ERROR: Tarball not found at path: $INPUT_TARBALL"
            echo "$error_message"
            echo "error-message=$error_message" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "üì¶ Extracting package info from tarball: $INPUT_TARBALL"

          # Extract package.json from tarball to get name and version
          # Note: Use -O without --wildcards for BSD tar (macOS) compatibility
          tar -xzf "$INPUT_TARBALL" -O package/package.json > /tmp/package.json.tarball 2>/dev/null

          if [ ! -s /tmp/package.json.tarball ]; then
            error_message="‚ùå ERROR: Could not extract package.json from tarball"
            echo "$error_message"
            echo "error-message=$error_message" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Get package name from tarball
          package_name=$(jq -r '.name // empty' /tmp/package.json.tarball)
          if [ -z "$package_name" ] || [ "$package_name" = "null" ]; then
            error_message="‚ùå ERROR: Tarball's package.json must have a 'name' field"
            echo "$error_message"
            echo "error-message=$error_message" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Get version from tarball
          version=$(jq -r '.version // empty' /tmp/package.json.tarball)
          if [ -z "$version" ] || [ "$version" = "null" ]; then
            error_message="‚ùå ERROR: Tarball's package.json must have a 'version' field"
            echo "$error_message"
            echo "error-message=$error_message" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "üì¶ Tarball package: $package_name@$version"
          echo "package-name=$package_name" >> $GITHUB_OUTPUT
          echo "version=$version" >> $GITHUB_OUTPUT
        else
          # Normal mode: validate package.json exists in current directory
          if [ ! -f "package.json" ]; then
            error_message="‚ùå ERROR: package.json not found in current directory. Make sure you're running this action in a directory with a package.json file"
            echo "$error_message"
            echo "error-message=$(extract_error "$error_message")" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Validate package.json is valid JSON
          if ! jq empty package.json 2>/dev/null; then
            error_message="‚ùå ERROR: package.json is not valid JSON"
            echo "$error_message"
            echo "error-message=$(extract_error "$error_message")" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Check if package has a name
          package_name=$(jq -r '.name // empty' package.json)
          if [ -z "$package_name" ] || [ "$package_name" = "null" ]; then
            error_message="‚ùå ERROR: package.json must have a 'name' field"
            echo "$error_message"
            echo "error-message=$(extract_error "$error_message")" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Output package name for use in error handling
          echo "package-name=$package_name" >> $GITHUB_OUTPUT
        fi

        # Detect authentication mode and package manager
        if [ -z "$INPUT_NPM_TOKEN" ]; then
          echo "üîê Using OIDC trusted publishing (no npm-token provided)"
          echo "üì¶ Using npm for OIDC (--provenance requires npm)"

          if [ -z "$ACTIONS_ID_TOKEN_REQUEST_URL" ]; then
            error_message="‚ùå ERROR: OIDC token not available. Add 'permissions: { id-token: write }' to your workflow"
            echo "$error_message"
            echo "error-message=$error_message" >> $GITHUB_OUTPUT
            exit 1
          fi
        fi

        if [ "$INPUT_NPM_TOKEN" ]; then
          echo "üîê Using token-based authentication"

          # Token mode: set NODE_AUTH_TOKEN so publishing works
          export NODE_AUTH_TOKEN="$INPUT_NPM_TOKEN"

          # Detect package manager for token-based publishing
          if [ -f "./yarn.lock" ]; then
            package_manager="yarn"
            echo "üì¶ Detected package manager: yarn"
          elif [ -f "./pnpm-lock.yaml" ]; then
            package_manager="pnpm"
            echo "üì¶ Detected package manager: pnpm"
          else
            package_manager="npm"
            echo "üì¶ Detected package manager: npm"
          fi
        fi

        # Generate version (skip in tarball mode - already extracted)
        if [ "$tarball_mode" = false ]; then
          version="0.0.0-PR-${PR}--$(echo ${SHA} | cut -c -7)"
          echo "üì¶ Publishing $package_name@$version with $package_manager"
          echo "version=$version" >> $GITHUB_OUTPUT

          # Update package.json version (all package managers support npm version)
          version_output=$(npm version $version --no-git-tag-version 2>&1)
          version_exit_code=$?
          if [ $version_exit_code -ne 0 ]; then
            error_message="‚ùå ERROR: Failed to update package version. Check if the version format is valid. Error: $version_output"
            echo "$error_message"
            echo "error-message=$(extract_error "$error_message")" >> $GITHUB_OUTPUT
            exit 1
          fi
        else
          echo "üì¶ Publishing $package_name@$version from tarball"
        fi

        # Publish package
        if [ "$tarball_mode" = true ]; then
          # SECURE TARBALL MODE: Publish pre-built tarball with --ignore-scripts
          echo "üîí Publishing tarball with --ignore-scripts (secure mode)"

          if [ -z "$INPUT_NPM_TOKEN" ]; then
            # OIDC mode with tarball
            publish_output=$(npm publish "$INPUT_TARBALL" --access public --tag pr --provenance --ignore-scripts 2>&1)
            publish_exit_code=$?

            if [ $publish_exit_code -ne 0 ]; then
              handle_publish_error "OIDC (tarball)" "$publish_output"
            fi
            echo "‚úÖ Successfully published $package_name@$version using OIDC (secure tarball mode)"
          else
            # Token mode with tarball - always use npm for tarball publishing
            publish_output=$(npm publish "$INPUT_TARBALL" --access public --tag pr --ignore-scripts 2>&1)
            publish_exit_code=$?

            if [ $publish_exit_code -ne 0 ]; then
              handle_publish_error "npm (tarball)" "$publish_output"
            fi
            echo "‚úÖ Successfully published $package_name@$version using npm (secure tarball mode)"
          fi
        else
          # NORMAL MODE: Traditional publishing (INSECURE for pull_request_target)
          if [ -z "$INPUT_NPM_TOKEN" ]; then
            echo "üì¶ Publishing with OIDC trusted publishing..."

            publish_output=$(npm publish --access public --tag pr --provenance 2>&1)
            publish_exit_code=$?

            if [ $publish_exit_code -ne 0 ]; then
              handle_publish_error "OIDC" "$publish_output"
            fi
            echo "‚úÖ Successfully published $package_name@$version using OIDC"
          else
            # Token mode: use detected package manager
            case "$package_manager" in
              "yarn")
                publish_output=$(yarn publish --access public --tag pr --new-version $version --no-git-tag-version --skip-check-working-tree 2>&1)
                publish_exit_code=$?
                if [ $publish_exit_code -ne 0 ]; then
                  handle_publish_error "yarn" "$publish_output"
                fi
                ;;
              "pnpm")
                publish_output=$(pnpm publish --no-git-checks --access public --tag pr 2>&1)
                publish_exit_code=$?
                if [ $publish_exit_code -ne 0 ]; then
                  handle_publish_error "pnpm" "$publish_output"
                fi
                ;;
              *)
                publish_output=$(npm publish --access public --tag pr 2>&1)
                publish_exit_code=$?
                if [ $publish_exit_code -ne 0 ]; then
                  handle_publish_error "npm" "$publish_output"
                fi
                ;;
            esac
            echo "‚úÖ Successfully published $package_name@$version using $package_manager"
          fi
        fi
      env:
        # CRITICAL: Use INPUT_NPM_TOKEN instead of NPM_TOKEN here to avoid
        # setting NPM_TOKEN in the environment when empty (which could break OIDC)
        INPUT_NPM_TOKEN: ${{ inputs.npm-token }}
        INPUT_TARBALL: ${{ inputs.tarball }}
        PR: ${{ github.event.number }}
        SHA: ${{ github.event.pull_request.head.sha }}

    - uses: codfish/actions/comment@v3
      if: failure() && inputs.comment == 'true'
      with:
        message: |
          ‚ùå **PR package publish failed!**

          Error: ${{ steps.publish.outputs.error-message }}

          üìã [View workflow logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for more details.
        upsert: true
        tag: ${{ inputs.comment-tag }}

    - uses: codfish/actions/comment@v3
      if: success() && inputs.comment == 'true'
      with:
        message: |
          ‚úÖ **PR package published successfully!**

          Install:

              npm install ${{ steps.publish.outputs.package-name }}@${{ steps.publish.outputs.version }}

          View on npm: https://www.npmjs.com/package/${{ steps.publish.outputs.package-name }}/v/${{ steps.publish.outputs.version }}
        upsert: true
        tag: ${{ inputs.comment-tag }}
